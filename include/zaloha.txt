#include "Arduino.h"
#include "robotka.h"
#include <iostream>
#include <thread>
#include "RBCX.h"
/////////////////////////////////////
static const uint8_t Bbutton1 = 34;
static const uint8_t Bbutton2 = 35;
const float roztec = 200.0; // roztec kol v mm


float koeficient_r_f = 1.066;
float koeficient_l_f = 1.034;
float koeficient_r_b = 1.066;
float koeficient_l_b = 1.035;


const float ML_25 = 1.00f, MP_25 = 1.00f;
const float ML_50 = 1.00f, MP_50 = 0.9987f;
const float ML_70 = 1.00f, MP_70 = 0.9021f;
const float ML_95 = 1.00f, MP_95 = 0.9790f;
//maximalni rychlost vice nez 60% z 4200 tzs, cirka 2600 je maximalka--65% na 95
// ted je potreba upravovat konstanty, podle noveho maxima 2600
const float ML_25_back = 1.00f, MP_25_back = 1.00f;
const float ML_50_back = 1.00f, MP_50_back = 0.99f;
const float ML_70_back = 1.00f, MP_70_back = 0.98f;
const float ML_95_back = 1.00f, MP_95_back = 0.97f;

///////////////////////////
void encoder(int cas)
{
    //m1 musí být -
    int M1_pos, M4_pos, odhylaka, integral, last_odchylka =0;
    int target = 20000;
    int a = 500;
    auto& man = rb::Manager::get(); // vytvoří referenci na man class
    for(int i = 0; i < target-1; i+=a)
    {
        odhylaka = M1_pos-M4_pos;
        integral += odhylaka; 
        man.motor(rb::MotorId::M1).requestInfo([&](rb::Motor& info) {
            M1_pos = -info.position();
        });
        man.motor(rb::MotorId::M4).requestInfo([&](rb::Motor& info) {
            M4_pos = info.position();
        });
        man.motor(rb::MotorId::M1).power(-i);
        man.motor(rb::MotorId::M4).power(i+odhylaka*20);
        delay(10);
        
    }
    integral =0;    //###
    for(int i =0; i<cas; i+=50)
    {
        odhylaka = M1_pos-M4_pos;
        integral += odhylaka; 

        man.motor(rb::MotorId::M1).power(-20000);
        man.motor(rb::MotorId::M4).power(20000+odhylaka*55+integral*0.01+(odhylaka-last_odchylka)*0.1);// i míň se to kvedla 50 -55 je ok  bez derivace )poslední čast na 2,5 m 3cm odchylka
        //! získá encodery z motoru
        man.motor(rb::MotorId::M1).requestInfo([&](rb::Motor& info) {
            M1_pos = -info.position();
        });
        man.motor(rb::MotorId::M4).requestInfo([&](rb::Motor& info) {
            M4_pos = info.position();
        });
        std::cout<<"odchylak: "<<M1_pos-M4_pos<<std::endl;

        delay(50);
        last_odchylka = odhylaka;
    }
    for(int i = target; i > 0; i -= a)
    {
        odhylaka = M1_pos - M4_pos;
        integral += odhylaka;
        
        man.motor(rb::MotorId::M1).requestInfo([&](rb::Motor& info) {
            M1_pos = -info.position();
        });
        man.motor(rb::MotorId::M4).requestInfo([&](rb::Motor& info) {
            M4_pos = info.position();
        });

        man.motor(rb::MotorId::M1).power(-i);
        man.motor(rb::MotorId::M4).power(i + odhylaka * 20);
        
        delay(10);
    }
}
////////////////////
void forward(float mm, float speed) {
    int M1_pos = 0, M4_pos = 0, odhylaka = 0, integral = 0, last_odchylka = 0;
    int M1_pos_up = 0, M4_pos_up = 0, M1_pos_start = 0, M4_pos_start = 0;
    int target = (32000 * speed/100);
    std::cout << "target: " << target << std::endl;
    int a = 300; // koeficient zrychlovani
    auto& man = rb::Manager::get(); // vytvoří referenci na man class

    // Startovní pozice
    man.motor(rb::MotorId::M1).requestInfo([&](rb::Motor& info) {
        M1_pos_start = -info.position();
    });
    man.motor(rb::MotorId::M4).requestInfo([&](rb::Motor& info) {
        M4_pos_start = info.position();
    });
    delay(50); // pro jistotu, aby se stihly načíst pozice

    Serial.printf("[FORWARD] Start M1_pos_start: %d, M4_pos_start: %d\n", M1_pos_start, M4_pos_start);

    int M1_must_go = ((mm / (127.5 * 3.141592)) * 40.4124852f * 48.f) + M1_pos_start; // přepočet mm na encodery
    int M4_must_go = ((mm / (127.5 * 3.141592)) * 40.4124852f * 48.f) + M4_pos_start;
    Serial.printf("[FORWARD] M1_must_go: %d, M4_must_go: %d\n", M1_must_go, M4_must_go);

    // Zrychlování
    for(int i = 0; i < target-1; i += a) {
        odhylaka = M1_pos - M4_pos;
        integral += odhylaka;
        man.motor(rb::MotorId::M1).requestInfo([&](rb::Motor& info) {
            M1_pos = -info.position();
        });
        man.motor(rb::MotorId::M4).requestInfo([&](rb::Motor& info) {
            M4_pos = info.position();
        });
        man.motor(rb::MotorId::M1).power(-i);
        man.motor(rb::MotorId::M4).power(i + odhylaka * 20);
        Serial.printf("[ACCEL] i: %d | M1_pos: %d | M4_pos: %d | odchylka: %d | integral: %d\n", i, M1_pos, M4_pos, odhylaka, integral);
        delay(10);
    }

    // Získání aktuální pozice po zrychlení
    man.motor(rb::MotorId::M1).requestInfo([&](rb::Motor& info) {
        M1_pos_up = -info.position();
    });
    man.motor(rb::MotorId::M4).requestInfo([&](rb::Motor& info) {
        M4_pos_up = info.position();
    });
    delay(50);

    int M1_pos_diff = M1_pos_up - M1_pos_start;
    int M4_pos_diff = M4_pos_up - M4_pos_start;
    Serial.printf("[AFTER ACCEL] M1_pos_up: %d, M4_pos_up: %d, M1_pos_diff: %d, M4_pos_diff: %d\n", M1_pos_up, M4_pos_up, M1_pos_diff, M4_pos_diff);

    integral = 0; // reset integrálu

    // Jízda na vzdálenost
    while (M1_pos < (M1_must_go - (2 * M1_pos_diff)) || M4_pos < (M4_must_go - (2 * M4_pos_diff))) {
        odhylaka = M1_pos - M4_pos;
        integral += odhylaka;

        man.motor(rb::MotorId::M1).power(-target);
        int powerM4 = target + odhylaka * 55 + integral * 0.01 + (odhylaka - last_odchylka) * 0.1;
        man.motor(rb::MotorId::M4).power(powerM4);

        man.motor(rb::MotorId::M1).requestInfo([&](rb::Motor& info) {
            M1_pos = -info.position();
        });
        man.motor(rb::MotorId::M4).requestInfo([&](rb::Motor& info) {
            M4_pos = info.position();
        });

        Serial.printf("[CONST] M1_pos: %d | M4_pos: %d | odchylka: %d | integral: %d | powerM4: %d\n", M1_pos, M4_pos, odhylaka, integral, powerM4);

        delay(50);
        last_odchylka = odhylaka;
    }
        integral = 0; // reset integrálu

    // Zpomalení
    for(int i = target ; i > 0 ; i -= a) {
        odhylaka = M1_pos - M4_pos;
        integral += odhylaka;

        man.motor(rb::MotorId::M1).requestInfo([&](rb::Motor& info) {
            M1_pos = -info.position(); 
        });
        man.motor(rb::MotorId::M4).requestInfo([&](rb::Motor& info) {
            M4_pos = info.position();
        });
        if(i < 5000){
          while(M1_pos < ( M1_must_go - (speed/50.0 * 20))){
            delay(10);
            man.motor(rb::MotorId::M1).requestInfo([&](rb::Motor& info) {
              M1_pos = -info.position();
            });
            man.motor(rb::MotorId::M4).requestInfo([&](rb::Motor& info) {
              M4_pos = info.position();
            });
            Serial.printf("[finishing] M1_pos: %d | M4_pos: %d | odchylka: %d | integral: %d\n", M1_pos, M4_pos, odhylaka, integral);
          }
        }
        man.motor(rb::MotorId::M1).power(-i);
        man.motor(rb::MotorId::M4).power(i );

        Serial.printf("[DECEL] i: %d | M1_pos: %d | M4_pos: %d | odchylka: %d | integral: %d\n", i, M1_pos, M4_pos, odhylaka, integral);

        delay(10);
    }
    int diff = abs(M1_pos - M4_pos);
    if (M1_pos < M4_pos) {
        Serial.printf("[DOROVNÁNÍ] M1 dojíždí: %d ticků\n", diff);
        while (M1_pos < M4_pos) {
            man.motor(rb::MotorId::M1).power(-3000);
            man.motor(rb::MotorId::M4).power(-1500);
            man.motor(rb::MotorId::M1).requestInfo([&](rb::Motor& info) {
                M1_pos = -info.position();
            });
            delay(5);
        }
    } else if (M4_pos < M1_pos) {
        Serial.printf("[DOROVNÁNÍ] M4 dojíždí: %d ticků\n", diff);
        while (M4_pos < M1_pos) {
            man.motor(rb::MotorId::M1).power(1500);
            man.motor(rb::MotorId::M4).power(3000);
            man.motor(rb::MotorId::M4).requestInfo([&](rb::Motor& info) {
                M4_pos = info.position();
            });
            delay(5);
        }
    }
    // Zastavit oba motory na konci
    man.motor(rb::MotorId::M1).power(0);
    man.motor(rb::MotorId::M4).power(0);
    Serial.println("[FORWARD] Dorovnání hotovo!");

    Serial.println("[FORWARD] Hotovo!");
}
void encodery() {
  Serial.printf("L: %f, R: %f\n", rkMotorsGetPositionLeft(), rkMotorsGetPositionRight());
}
void radius_r(int degrees, int polomer, int speed)
{
  float sR = speed * ((polomer) / (polomer + roztec));
  float sL = speed ;
  if(degrees > 0){
  float stupne = degrees * koeficient_r_f;
  rkMotorsDrive((((polomer + roztec) * PI * stupne) / 180)  ,(( polomer * PI * stupne) / 180) , sL * MP_50_back , sR * MP_50);
  }
  else{
  float stupne= degrees * koeficient_r_b;
  rkMotorsDrive((((polomer + roztec) * PI * stupne) / 180) , (( polomer * PI * stupne) / 180)  , sL * MP_50_back , sR * MP_50_back);
  }
}
void radius_l(int degrees, int polomer, int speed){
  float sR = speed ;
  float sL = speed * ((polomer) / (polomer + roztec));
  if(degrees > 0){
  float stupne = degrees * koeficient_l_f;
  rkMotorsDrive((( polomer * PI * stupne) / 180) , (((polomer + roztec) * PI * stupne) / 180)  , sL * MP_50_back , sR * MP_50);
  }
  else{
  float stupne = degrees * koeficient_l_b;
  rkMotorsDrive((( polomer * PI * stupne) / 180), (((polomer + roztec) * PI * stupne) / 180) , sL * ML_50_back , sR * MP_50_back);
  }
}
void turn_on_spot(int degrees){
  rkMotorsDrive(((degrees/360) * PI * roztec), ((degrees/360) * -PI * roztec), 30 * MP_50_back , 30 * MP_50);
}
void back_buttons(int speed)
{
    rkMotorsSetPower(-(speed * MP_50_back), -(speed * MP_50));
    while (true)
    {
      if ((digitalRead(Bbutton1) == LOW)&&(digitalRead(Bbutton2) == LOW)){
        break;
      }
      delay(100);
    }
    delay(150);
    Serial.println("Obě Tlačítka STISKNUTY!");
    rkMotorsSetPower(0, 0);
}
//timeout